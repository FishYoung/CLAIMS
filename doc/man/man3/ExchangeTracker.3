.TH "ExchangeTracker" 3 "Thu Nov 12 2015" "Claims" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ExchangeTracker \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <exchange_tracker\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBExchangeTrackerActor\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBExchangeTracker\fP ()"
.br
.ti -1c
.RI "virtual \fB~ExchangeTracker\fP ()"
.br
.ti -1c
.RI "bool \fBRegisterExchange\fP (\fBExchangeID\fP exchange_id, std::string port)"
.br
.ti -1c
.RI "void \fBLogoutExchange\fP (const \fBExchangeID\fP &exchange_id)"
.br
.ti -1c
.RI "bool \fBAskForSocketConnectionInfo\fP (\fBExchangeID\fP exchange_id, \fBNodeID\fP target_id, \fBNodeAddress\fP &node_addr)"
.br
.ti -1c
.RI "void \fBprintAllExchangeId\fP () const "
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Theron::EndPoint * \fBendpoint\fP"
.br
.ti -1c
.RI "Theron::Framework * \fBframework\fP"
.br
.ti -1c
.RI "Theron::Actor * \fBactor\fP"
.br
.ti -1c
.RI "boost::unordered_map
.br
< \fBExchangeID\fP, std::string > \fBid_to_port\fP"
.br
.ti -1c
.RI "\fBLogging\fP * \fBlogging_\fP"
.br
.ti -1c
.RI "\fBLock\fP \fBlock_\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBRegisterActor\fP"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ExchangeTracker::ExchangeTracker ()"

.PP
References actor, endpoint, framework, Environment::getEndPoint(), Environment::getInstance(), Environment::getNodeID(), Logging::log(), and logging_\&.
.SS "ExchangeTracker::~ExchangeTracker ()\fC [virtual]\fP"

.PP
References actor, framework, and logging_\&.
.SH "Member Function Documentation"
.PP 
.SS "bool ExchangeTracker::AskForSocketConnectionInfo (\fBExchangeID\fPexchange_id, \fBNodeID\fPtarget_id, \fBNodeAddress\fP &node_addr)"
TODO: In current version, the request is only tried once\&. In the future, the request should be sent repeatedly until the reply is received or the times of timeouts exceeds some threshold\&.
.PP
References curtick(), endpoint, framework, NodeRegisterMessage::get_ip(), NodeAddress::ip, NodeRegisterMessage::ip, NodeAddress::port, NodeRegisterMessage::port, and TimeOutReceiver::~TimeOutReceiver()\&.
.PP
Referenced by claims::physical_operator::ExchangeSender::ConnectToUpper(), and claims::physical_operator::ExchangeMerger::IsOtherMergersRegistered()\&.
.SS "void ExchangeTracker::LogoutExchange (const \fBExchangeID\fP &exchange_id)"

.PP
References Lock::acquire(), id_to_port, lock_, Logging::log(), logging_, and Lock::release()\&.
.PP
Referenced by claims::physical_operator::ExchangeMerger::Close()\&.
.SS "void ExchangeTracker::printAllExchangeId () const"

.PP
References id_to_port\&.
.SS "bool ExchangeTracker::RegisterExchange (\fBExchangeID\fPexchange_id, std::stringport)"

.PP
References Lock::acquire(), id_to_port, lock_, Logging::log(), logging_, and Lock::release()\&.
.PP
Referenced by claims::physical_operator::ExchangeMerger::RegisterExchange()\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class RegisterActor\fC [friend]\fP"
RegisterActor 
.SH "Member Data Documentation"
.PP 
.SS "Theron::Actor* ExchangeTracker::actor\fC [private]\fP"

.PP
Referenced by ExchangeTracker(), and ~ExchangeTracker()\&.
.SS "Theron::EndPoint* ExchangeTracker::endpoint\fC [private]\fP"

.PP
Referenced by AskForSocketConnectionInfo(), and ExchangeTracker()\&.
.SS "Theron::Framework* ExchangeTracker::framework\fC [private]\fP"

.PP
Referenced by AskForSocketConnectionInfo(), ExchangeTracker(), and ~ExchangeTracker()\&.
.SS "boost::unordered_map<\fBExchangeID\fP,std::string> ExchangeTracker::id_to_port\fC [private]\fP"

.PP
Referenced by LogoutExchange(), printAllExchangeId(), and RegisterExchange()\&.
.SS "\fBLock\fP ExchangeTracker::lock_\fC [private]\fP"

.PP
Referenced by LogoutExchange(), and RegisterExchange()\&.
.SS "\fBLogging\fP* ExchangeTracker::logging_\fC [private]\fP"

.PP
Referenced by ExchangeTracker(), LogoutExchange(), RegisterExchange(), and ~ExchangeTracker()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Claims from the source code\&.
