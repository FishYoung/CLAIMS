.TH "IndexScanIterator" 3 "Thu Nov 12 2015" "Claims" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IndexScanIterator \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <IndexScanIterator\&.h>\fP
.PP
Inherits \fBclaims::physical_operator::PhysicalOperator\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBquery_range\fP"
.br
.ti -1c
.RI "struct \fBremaining_block\fP"
.br
.ti -1c
.RI "class \fBState\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIndexScanIterator\fP ()"
.br
.ti -1c
.RI "\fBIndexScanIterator\fP (\fBState\fP state)"
.br
.ti -1c
.RI "virtual \fB~IndexScanIterator\fP ()"
.br
.ti -1c
.RI "bool \fBOpen\fP (const \fBPartitionOffset\fP &partition_off=0)"
.br
.ti -1c
.RI "bool \fBNext\fP (\fBBlockStreamBase\fP *block)"
.br
.ti -1c
.RI "bool \fBClose\fP ()"
.br
.ti -1c
.RI "void \fBPrint\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBatomicPushRemainingBlock\fP (\fBremaining_block\fP rb)"
.br
.ti -1c
.RI "bool \fBatomicPopRemainingBlock\fP (\fBremaining_block\fP &rb)"
.br
.ti -1c
.RI "void \fBAtomicPushBlockStream\fP (\fBBlockStreamBase\fP *block)"
.br
.ti -1c
.RI "\fBBlockStreamBase\fP * \fBAtomicPopBlockStream\fP ()"
.br
.ti -1c
.RI "bool \fBaskForNextBlock\fP (\fBremaining_block\fP &rb)"
.br
.ti -1c
.RI "template<class Archive > void \fBserialize\fP (Archive &ar, const unsigned int version)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBState\fP \fBstate_\fP"
.br
.ti -1c
.RI "\fBPartitionStorage::PartitionReaderItetaor\fP * \fBpartition_reader_iterator_\fP"
.br
.ti -1c
.RI "\fBChunkReaderIterator\fP * \fBchunk_reader_iterator_\fP"
.br
.ti -1c
.RI "std::map< \fBChunkID\fP, void * > \fBcsb_index_list_\fP"
.br
.ti -1c
.RI "std::list< \fBremaining_block\fP > \fBremaining_block_list_\fP"
.br
.ti -1c
.RI "std::list< \fBBlockStreamBase\fP * > \fBblock_stream_list_\fP"
.br
.ti -1c
.RI "\fBLock\fP \fBlock_\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBboost::serialization::access\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IndexScanIterator::IndexScanIterator ()"

.PP
References claims::physical_operator::PhysicalOperator::InitExpandedStatus()\&.
.SS "IndexScanIterator::IndexScanIterator (\fBState\fPstate)"

.PP
References csb_index_list_, and claims::physical_operator::PhysicalOperator::InitExpandedStatus()\&.
.SS "IndexScanIterator::~IndexScanIterator ()\fC [virtual]\fP"

.SH "Member Function Documentation"
.PP 
.SS "bool IndexScanIterator::askForNextBlock (\fBremaining_block\fP &rb)\fC [private]\fP"
\fIfor testing\fP/ unsigned long count = 0;
.PP
\fIfor testing\fP/ cout << 'Total count: ' << count << endl; 
.PP
References IndexScanIterator::remaining_block::block, IndexScanIterator::remaining_block::block_off, chunk_reader_iterator_, csb_index_list_, IndexManager::getIndexType(), IndexManager::getInstance(), IndexScanIterator::State::index_id_, IndexScanIterator::remaining_block::iter_result_map, IndexScanIterator::remaining_block::iter_result_vector, ChunkReaderIterator::nextBlock(), PartitionStorage::PartitionReaderItetaor::nextChunk(), partition_reader_iterator_, IndexScanIterator::State::query_range_, IndexScanIterator::remaining_block::result_set, state_, t_boolean, t_date, t_datetime, t_decimal, t_double, t_float, t_int, t_smallInt, t_string, t_time, t_u_long, and t_u_smallInt\&.
.PP
Referenced by Next()\&.
.SS "\fBBlockStreamBase\fP * IndexScanIterator::AtomicPopBlockStream ()\fC [private]\fP"

.PP
References Lock::acquire(), block_stream_list_, lock_, and Lock::release()\&.
.PP
Referenced by Next()\&.
.SS "bool IndexScanIterator::atomicPopRemainingBlock (\fBremaining_block\fP &rb)\fC [private]\fP"

.PP
References Lock::acquire(), lock_, Lock::release(), and remaining_block_list_\&.
.PP
Referenced by Next()\&.
.SS "void IndexScanIterator::AtomicPushBlockStream (\fBBlockStreamBase\fP *block)\fC [private]\fP"

.PP
References Lock::acquire(), block_stream_list_, lock_, and Lock::release()\&.
.PP
Referenced by Next(), and Open()\&.
.SS "void IndexScanIterator::atomicPushRemainingBlock (\fBremaining_block\fPrb)\fC [private]\fP"

.PP
References Lock::acquire(), lock_, Lock::release(), and remaining_block_list_\&.
.PP
Referenced by Next()\&.
.SS "bool IndexScanIterator::Close ()\fC [virtual]\fP"

.PP
Reimplemented from \fBclaims::physical_operator::PhysicalOperator\fP\&.
.PP
References block_stream_list_, claims::physical_operator::PhysicalOperator::InitExpandedStatus(), partition_reader_iterator_, and remaining_block_list_\&.
.SS "bool IndexScanIterator::Next (\fBBlockStreamBase\fP *block)\fC [virtual]\fP"

.PP
Reimplemented from \fBclaims::physical_operator::PhysicalOperator\fP\&.
.PP
References BlockStreamBase::allocateTuple(), askForNextBlock(), AtomicPopBlockStream(), atomicPopRemainingBlock(), AtomicPushBlockStream(), atomicPushRemainingBlock(), IndexScanIterator::remaining_block::block, IndexScanIterator::remaining_block::block_off, Schema::copyTuple(), BlockStreamBase::createIterator(), BlockStreamBase::Empty(), BlockStreamBase::BlockStreamTraverseIterator::getTuple(), Schema::getTupleMaxSize(), IndexScanIterator::remaining_block::iter_result_map, IndexScanIterator::remaining_block::iter_result_vector, IndexScanIterator::remaining_block::iterator, IndexScanIterator::remaining_block::result_set, IndexScanIterator::State::schema_, BlockStreamBase::setEmpty(), and state_\&.
.SS "bool IndexScanIterator::Open (const \fBPartitionOffset\fP &part_off = \fC0\fP)\fC [virtual]\fP"
Because that \fBboost::serialization\fP will allocate an instance of this class when deserializing, and hence the following three virtual method cannot be pure\&. 
.PP
Reimplemented from \fBclaims::physical_operator::PhysicalOperator\fP\&.
.PP
References AtomicPushBlockStream(), claims::physical_operator::PhysicalOperator::BarrierArrive(), IndexScanIterator::State::block_size_, PartitionStorage::createAtomicReaderIterator(), BlockStreamBase::createBlockWithDesirableSerilaizedSize(), csb_index_list_, IndexManager::getAttrIndex(), IndexManager::getInstance(), BlockManager::getInstance(), PartitionID::getName(), claims::physical_operator::PhysicalOperator::GetReturnStatus(), IndexScanIterator::State::index_id_, partition_reader_iterator_, IndexScanIterator::State::projection_id_, IndexScanIterator::State::schema_, claims::physical_operator::PhysicalOperator::SetReturnStatus(), state_, and claims::physical_operator::PhysicalOperator::TryEntryIntoSerializedSection()\&.
.SS "void IndexScanIterator::Print ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBclaims::physical_operator::PhysicalOperator\fP\&.
.SS "template<class Archive > void IndexScanIterator::serialize (Archive &ar, const unsigned intversion)\fC [inline]\fP, \fC [private]\fP"

.PP
References state_\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class boost::serialization::access\fC [friend]\fP"

.SH "Member Data Documentation"
.PP 
.SS "std::list<\fBBlockStreamBase\fP*> IndexScanIterator::block_stream_list_\fC [private]\fP"

.PP
Referenced by AtomicPopBlockStream(), AtomicPushBlockStream(), and Close()\&.
.SS "\fBChunkReaderIterator\fP* IndexScanIterator::chunk_reader_iterator_\fC [private]\fP"

.PP
Referenced by askForNextBlock()\&.
.SS "std::map<\fBChunkID\fP, void*> IndexScanIterator::csb_index_list_\fC [private]\fP"

.PP
Referenced by askForNextBlock(), IndexScanIterator(), and Open()\&.
.SS "\fBLock\fP IndexScanIterator::lock_\fC [private]\fP"

.PP
Referenced by AtomicPopBlockStream(), atomicPopRemainingBlock(), AtomicPushBlockStream(), and atomicPushRemainingBlock()\&.
.SS "\fBPartitionStorage::PartitionReaderItetaor\fP* IndexScanIterator::partition_reader_iterator_\fC [private]\fP"

.PP
Referenced by askForNextBlock(), Close(), and Open()\&.
.SS "std::list<\fBremaining_block\fP> IndexScanIterator::remaining_block_list_\fC [private]\fP"

.PP
Referenced by atomicPopRemainingBlock(), atomicPushRemainingBlock(), and Close()\&.
.SS "\fBState\fP IndexScanIterator::state_\fC [private]\fP"

.PP
Referenced by askForNextBlock(), Next(), Open(), and serialize()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Claims from the source code\&.
