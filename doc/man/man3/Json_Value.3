.TH "Json::Value" 3 "Thu Nov 12 2015" "Claims" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Json::Value \- 
.PP
Represents a \fCJSON\fP value\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <json\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBCommentInfo\fP"
.br
.ti -1c
.RI "class \fBCZString\fP"
.br
.ti -1c
.RI "union \fBValueHolder\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef std::vector< std::string > \fBMembers\fP"
.br
.ti -1c
.RI "typedef \fBValueIterator\fP \fBiterator\fP"
.br
.ti -1c
.RI "typedef \fBValueConstIterator\fP \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef \fBJson::UInt\fP \fBUInt\fP"
.br
.ti -1c
.RI "typedef \fBJson::Int\fP \fBInt\fP"
.br
.ti -1c
.RI "typedef \fBJson::UInt64\fP \fBUInt64\fP"
.br
.ti -1c
.RI "typedef \fBJson::Int64\fP \fBInt64\fP"
.br
.ti -1c
.RI "typedef \fBJson::LargestInt\fP \fBLargestInt\fP"
.br
.ti -1c
.RI "typedef \fBJson::LargestUInt\fP \fBLargestUInt\fP"
.br
.ti -1c
.RI "typedef \fBJson::ArrayIndex\fP \fBArrayIndex\fP"
.br
.ti -1c
.RI "typedef std::map< \fBCZString\fP, \fBValue\fP > \fBObjectValues\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBValue\fP (\fBValueType\fP \fBtype\fP=\fBnullValue\fP)"
.br
.RI "\fICreate a default \fBValue\fP of the given type\&. \fP"
.ti -1c
.RI "\fBValue\fP (\fBInt\fP value)"
.br
.ti -1c
.RI "\fBValue\fP (\fBUInt\fP value)"
.br
.ti -1c
.RI "\fBValue\fP (\fBInt64\fP value)"
.br
.ti -1c
.RI "\fBValue\fP (\fBUInt64\fP value)"
.br
.ti -1c
.RI "\fBValue\fP (double value)"
.br
.ti -1c
.RI "\fBValue\fP (const char *value)"
.br
.ti -1c
.RI "\fBValue\fP (const char *beginValue, const char *endValue)"
.br
.ti -1c
.RI "\fBValue\fP (const \fBStaticString\fP &value)"
.br
.RI "\fIConstructs a value from a static string\&. \fP"
.ti -1c
.RI "\fBValue\fP (const std::string &value)"
.br
.ti -1c
.RI "\fBValue\fP (bool value)"
.br
.ti -1c
.RI "\fBValue\fP (const \fBValue\fP &other)"
.br
.ti -1c
.RI "\fB~Value\fP ()"
.br
.ti -1c
.RI "\fBValue\fP & \fBoperator=\fP (\fBValue\fP other)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBValue\fP &other)"
.br
.ti -1c
.RI "\fBValueType\fP \fBtype\fP () const "
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBValue\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBValue\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBValue\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBValue\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBValue\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBValue\fP &other) const "
.br
.ti -1c
.RI "int \fBcompare\fP (const \fBValue\fP &other) const "
.br
.ti -1c
.RI "const char * \fBasCString\fP () const "
.br
.ti -1c
.RI "std::string \fBasString\fP () const "
.br
.ti -1c
.RI "\fBInt\fP \fBasInt\fP () const "
.br
.ti -1c
.RI "\fBUInt\fP \fBasUInt\fP () const "
.br
.ti -1c
.RI "\fBInt64\fP \fBasInt64\fP () const "
.br
.ti -1c
.RI "\fBUInt64\fP \fBasUInt64\fP () const "
.br
.ti -1c
.RI "\fBLargestInt\fP \fBasLargestInt\fP () const "
.br
.ti -1c
.RI "\fBLargestUInt\fP \fBasLargestUInt\fP () const "
.br
.ti -1c
.RI "float \fBasFloat\fP () const "
.br
.ti -1c
.RI "double \fBasDouble\fP () const "
.br
.ti -1c
.RI "bool \fBasBool\fP () const "
.br
.ti -1c
.RI "bool \fBisNull\fP () const "
.br
.ti -1c
.RI "bool \fBisBool\fP () const "
.br
.ti -1c
.RI "bool \fBisInt\fP () const "
.br
.ti -1c
.RI "bool \fBisInt64\fP () const "
.br
.ti -1c
.RI "bool \fBisUInt\fP () const "
.br
.ti -1c
.RI "bool \fBisUInt64\fP () const "
.br
.ti -1c
.RI "bool \fBisIntegral\fP () const "
.br
.ti -1c
.RI "bool \fBisDouble\fP () const "
.br
.ti -1c
.RI "bool \fBisNumeric\fP () const "
.br
.ti -1c
.RI "bool \fBisString\fP () const "
.br
.ti -1c
.RI "bool \fBisArray\fP () const "
.br
.ti -1c
.RI "bool \fBisObject\fP () const "
.br
.ti -1c
.RI "bool \fBisConvertibleTo\fP (\fBValueType\fP other) const "
.br
.ti -1c
.RI "\fBArrayIndex\fP \fBsize\fP () const "
.br
.RI "\fINumber of values in array or object\&. \fP"
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.RI "\fIReturn true if empty array, empty object, or null; otherwise, false\&. \fP"
.ti -1c
.RI "bool \fBoperator!\fP () const "
.br
.RI "\fIReturn \fBisNull()\fP \fP"
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBresize\fP (\fBArrayIndex\fP \fBsize\fP)"
.br
.ti -1c
.RI "\fBValue\fP & \fBoperator[]\fP (\fBArrayIndex\fP index)"
.br
.ti -1c
.RI "\fBValue\fP & \fBoperator[]\fP (int index)"
.br
.ti -1c
.RI "const \fBValue\fP & \fBoperator[]\fP (\fBArrayIndex\fP index) const "
.br
.ti -1c
.RI "const \fBValue\fP & \fBoperator[]\fP (int index) const "
.br
.ti -1c
.RI "\fBValue\fP \fBget\fP (\fBArrayIndex\fP index, const \fBValue\fP &defaultValue) const "
.br
.ti -1c
.RI "bool \fBisValidIndex\fP (\fBArrayIndex\fP index) const "
.br
.RI "\fIReturn true if index < \fBsize()\fP\&. \fP"
.ti -1c
.RI "\fBValue\fP & \fBappend\fP (const \fBValue\fP &value)"
.br
.RI "\fIAppend value to array at the end\&. \fP"
.ti -1c
.RI "\fBValue\fP & \fBoperator[]\fP (const char *key)"
.br
.RI "\fIAccess an object value by name, create a null member if it does not exist\&. \fP"
.ti -1c
.RI "const \fBValue\fP & \fBoperator[]\fP (const char *key) const "
.br
.ti -1c
.RI "\fBValue\fP & \fBoperator[]\fP (const std::string &key)"
.br
.RI "\fIAccess an object value by name, create a null member if it does not exist\&. \fP"
.ti -1c
.RI "const \fBValue\fP & \fBoperator[]\fP (const std::string &key) const "
.br
.ti -1c
.RI "\fBValue\fP & \fBoperator[]\fP (const \fBStaticString\fP &key)"
.br
.RI "\fIAccess an object value by name, create a null member if it does not exist\&. \fP"
.ti -1c
.RI "\fBValue\fP \fBget\fP (const char *key, const \fBValue\fP &defaultValue) const "
.br
.RI "\fIReturn the member named key if it exist, defaultValue otherwise\&. \fP"
.ti -1c
.RI "\fBValue\fP \fBget\fP (const std::string &key, const \fBValue\fP &defaultValue) const "
.br
.RI "\fIReturn the member named key if it exist, defaultValue otherwise\&. \fP"
.ti -1c
.RI "\fBValue\fP \fBremoveMember\fP (const char *key)"
.br
.RI "\fIRemove and return the named member\&. \fP"
.ti -1c
.RI "\fBValue\fP \fBremoveMember\fP (const std::string &key)"
.br
.RI "\fISame as \fBremoveMember(const char*)\fP \fP"
.ti -1c
.RI "bool \fBisMember\fP (const char *key) const "
.br
.RI "\fIReturn true if the object has a member named key\&. \fP"
.ti -1c
.RI "bool \fBisMember\fP (const std::string &key) const "
.br
.RI "\fIReturn true if the object has a member named key\&. \fP"
.ti -1c
.RI "\fBMembers\fP \fBgetMemberNames\fP () const "
.br
.RI "\fIReturn a list of the member names\&. \fP"
.ti -1c
.RI "void \fBsetComment\fP (const char *comment, \fBCommentPlacement\fP placement)"
.br
.RI "\fIComments must be //\&.\&.\&. or /* \&.\&.\&. */\&. \fP"
.ti -1c
.RI "void \fBsetComment\fP (const std::string &comment, \fBCommentPlacement\fP placement)"
.br
.RI "\fIComments must be //\&.\&.\&. or /* \&.\&.\&. */\&. \fP"
.ti -1c
.RI "bool \fBhasComment\fP (\fBCommentPlacement\fP placement) const "
.br
.ti -1c
.RI "std::string \fBgetComment\fP (\fBCommentPlacement\fP placement) const "
.br
.RI "\fIInclude delimiters and embedded newlines\&. \fP"
.ti -1c
.RI "std::string \fBtoStyledString\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP ()"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.ti -1c
.RI "void \fBsetOffsetStart\fP (size_t start)"
.br
.ti -1c
.RI "void \fBsetOffsetLimit\fP (size_t limit)"
.br
.ti -1c
.RI "size_t \fBgetOffsetStart\fP () const "
.br
.ti -1c
.RI "size_t \fBgetOffsetLimit\fP () const "
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const \fBValue\fP & \fBnull\fP = reinterpret_cast<const \fBValue\fP&>(\fBkNullRef\fP)"
.br
.ti -1c
.RI "static const \fBLargestInt\fP \fBminLargestInt\fP = \fBLargestInt\fP(~(\fBLargestUInt\fP(-1) / 2))"
.br
.RI "\fIMinimum signed integer value that can be stored in a \fBJson::Value\fP\&. \fP"
.ti -1c
.RI "static const \fBLargestInt\fP \fBmaxLargestInt\fP = \fBLargestInt\fP(\fBLargestUInt\fP(-1) / 2)"
.br
.RI "\fIMaximum signed integer value that can be stored in a \fBJson::Value\fP\&. \fP"
.ti -1c
.RI "static const \fBLargestUInt\fP \fBmaxLargestUInt\fP = \fBLargestUInt\fP(-1)"
.br
.RI "\fIMaximum unsigned integer value that can be stored in a \fBJson::Value\fP\&. \fP"
.ti -1c
.RI "static const \fBInt\fP \fBminInt\fP = \fBInt\fP(~(\fBUInt\fP(-1) / 2))"
.br
.RI "\fIMinimum signed int value that can be stored in a \fBJson::Value\fP\&. \fP"
.ti -1c
.RI "static const \fBInt\fP \fBmaxInt\fP = \fBInt\fP(\fBUInt\fP(-1) / 2)"
.br
.RI "\fIMaximum signed int value that can be stored in a \fBJson::Value\fP\&. \fP"
.ti -1c
.RI "static const \fBUInt\fP \fBmaxUInt\fP = \fBUInt\fP(-1)"
.br
.RI "\fIMaximum unsigned int value that can be stored in a \fBJson::Value\fP\&. \fP"
.ti -1c
.RI "static const \fBInt64\fP \fBminInt64\fP = \fBInt64\fP(~(\fBUInt64\fP(-1) / 2))"
.br
.RI "\fIMinimum signed 64 bits int value that can be stored in a \fBJson::Value\fP\&. \fP"
.ti -1c
.RI "static const \fBInt64\fP \fBmaxInt64\fP = \fBInt64\fP(\fBUInt64\fP(-1) / 2)"
.br
.RI "\fIMaximum signed 64 bits int value that can be stored in a \fBJson::Value\fP\&. \fP"
.ti -1c
.RI "static const \fBUInt64\fP \fBmaxUInt64\fP = \fBUInt64\fP(-1)"
.br
.RI "\fIMaximum unsigned 64 bits int value that can be stored in a \fBJson::Value\fP\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBValue\fP & \fBresolveReference\fP (const char *key, bool isStatic)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "union \fBJson::Value::ValueHolder\fP \fBvalue_\fP"
.br
.ti -1c
.RI "\fBValueType\fP \fBtype_\fP: 8"
.br
.ti -1c
.RI "int \fBallocated_\fP: 1"
.br
.ti -1c
.RI "\fBCommentInfo\fP * \fBcomments_\fP"
.br
.ti -1c
.RI "size_t \fBstart_\fP"
.br
.ti -1c
.RI "size_t \fBlimit_\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBValueIteratorBase\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Represents a \fCJSON\fP value\&. 

This class is a discriminated union wrapper that can represents a:
.IP "\(bu" 2
signed integer [range: \fBValue::minInt\fP - \fBValue::maxInt\fP]
.IP "\(bu" 2
unsigned integer (range: 0 - \fBValue::maxUInt\fP)
.IP "\(bu" 2
double
.IP "\(bu" 2
UTF-8 string
.IP "\(bu" 2
boolean
.IP "\(bu" 2
'null'
.IP "\(bu" 2
an ordered list of \fBValue\fP
.IP "\(bu" 2
collection of name/value pairs (javascript object)
.PP
.PP
The type of the held value is represented by a \fBValueType\fP and can be obtained using \fBtype()\fP\&.
.PP
values of an \fBobjectValue\fP or \fBarrayValue\fP can be accessed using \fBoperator[]()\fP methods\&. Non const methods will automatically create the a \fBnullValue\fP element if it does not exist\&. The sequence of an \fBarrayValue\fP will be automatically resize and initialized with \fBnullValue\fP\&. \fBresize()\fP can be used to enlarge or truncate an \fBarrayValue\fP\&.
.PP
The \fBget()\fP methods can be used to obtanis default value in the case the required element does not exist\&.
.PP
It is possible to iterate over the list of a \fBobjectValue\fP values using the \fBgetMemberNames()\fP method\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "typedef \fBJson::ArrayIndex\fP \fBJson::Value::ArrayIndex\fP"

.SS "typedef \fBValueConstIterator\fP \fBJson::Value::const_iterator\fP"

.SS "typedef \fBJson::Int\fP \fBJson::Value::Int\fP"

.SS "typedef \fBJson::Int64\fP \fBJson::Value::Int64\fP"

.SS "typedef \fBValueIterator\fP \fBJson::Value::iterator\fP"

.SS "typedef \fBJson::LargestInt\fP \fBJson::Value::LargestInt\fP"

.SS "typedef \fBJson::LargestUInt\fP \fBJson::Value::LargestUInt\fP"

.SS "typedef std::vector<std::string> \fBJson::Value::Members\fP"

.SS "typedef std::map<\fBCZString\fP, \fBValue\fP> \fBJson::Value::ObjectValues\fP"

.SS "typedef \fBJson::UInt\fP \fBJson::Value::UInt\fP"

.SS "typedef \fBJson::UInt64\fP \fBJson::Value::UInt64\fP"

.SH "Constructor & Destructor Documentation"
.PP 
.SS "Json::Value::Value (\fBValueType\fPtype = \fC\fBnullValue\fP\fP)"

.PP
Create a default \fBValue\fP of the given type\&. 
.PP
.nf
This is a very useful constructor.
To create an empty array, pass arrayValue.
To create an empty object, pass objectValue.
Another Value can then be set to this one by assignment.

.fi
.PP
 This is useful since \fBclear()\fP and \fBresize()\fP will not alter types\&. 
.PP
.nf
Examples:

.fi
.PP
 
.PP
.nf
Json::Value null_value; // null
Json::Value arr_value(Json::arrayValue); // []
Json::Value obj_value(Json::objectValue); // {}

.fi
.PP
 
.PP
References Json::arrayValue, Json::Value::ValueHolder::bool_, Json::booleanValue, Json::Value::ValueHolder::int_, Json::intValue, JSON_ASSERT_UNREACHABLE, Json::Value::ValueHolder::map_, Json::nullValue, Json::objectValue, Json::Value::ValueHolder::real_, Json::realValue, Json::Value::ValueHolder::string_, Json::stringValue, Json::uintValue, and value_\&.
.PP
Referenced by operator[](), resize(), and resolveReference()\&.
.SS "Json::Value::Value (\fBInt\fPvalue)"

.PP
References Json::Value::ValueHolder::int_, and value_\&.
.SS "Json::Value::Value (\fBUInt\fPvalue)"

.PP
References Json::Value::ValueHolder::uint_, and value_\&.
.SS "Json::Value::Value (\fBInt64\fPvalue)"

.PP
References Json::Value::ValueHolder::int_, and value_\&.
.SS "Json::Value::Value (\fBUInt64\fPvalue)"

.PP
References Json::Value::ValueHolder::uint_, and value_\&.
.SS "Json::Value::Value (doublevalue)"

.PP
References Json::Value::ValueHolder::real_, and value_\&.
.SS "Json::Value::Value (const char *value)"

.PP
References Json::duplicateStringValue(), Json::Value::ValueHolder::string_, and value_\&.
.SS "Json::Value::Value (const char *beginValue, const char *endValue)"

.PP
References Json::duplicateStringValue(), Json::Value::ValueHolder::string_, and value_\&.
.SS "Json::Value::Value (const \fBStaticString\fP &value)"

.PP
Constructs a value from a static string\&. Like other value string constructor but do not duplicate the string for internal storage\&. The given string must remain alive after the call to this constructor\&. Example of usage: 
.PP
.nf
* Json::Value aValue( StaticString("some text") );
* 

.fi
.PP
 
.PP
References Json::StaticString::c_str(), Json::Value::ValueHolder::string_, and value_\&.
.SS "Json::Value::Value (const std::string &value)"

.PP
References Json::duplicateStringValue(), Json::Value::ValueHolder::string_, and value_\&.
.SS "Json::Value::Value (boolvalue)"

.PP
References Json::Value::ValueHolder::bool_, and value_\&.
.SS "Json::Value::Value (const \fBValue\fP &other)"

.PP
References allocated_, Json::arrayValue, Json::booleanValue, Json::Value::CommentInfo::comment_, comments_, Json::duplicateStringValue(), Json::intValue, JSON_ASSERT_UNREACHABLE, Json::Value::ValueHolder::map_, Json::nullValue, Json::numberOfCommentPlacement, Json::objectValue, Json::realValue, Json::Value::CommentInfo::setComment(), Json::Value::ValueHolder::string_, Json::stringValue, type_, Json::uintValue, and value_\&.
.SS "Json::Value::~Value ()"

.PP
References allocated_, Json::arrayValue, Json::booleanValue, comments_, Json::intValue, JSON_ASSERT_UNREACHABLE, Json::Value::ValueHolder::map_, Json::nullValue, Json::objectValue, Json::realValue, Json::releaseStringValue(), Json::Value::ValueHolder::string_, Json::stringValue, type_, Json::uintValue, and value_\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBValue\fP & Json::Value::append (const \fBValue\fP &value)"

.PP
Append value to array at the end\&. Equivalent to jsonvalue[jsonvalue\&.size()] = value; 
.PP
References size()\&.
.PP
Referenced by ClientListener::sendJsonPacket()\&.
.SS "bool Json::Value::asBool () const"

.PP
References Json::Value::ValueHolder::bool_, Json::booleanValue, Json::Value::ValueHolder::int_, Json::intValue, JSON_FAIL_MESSAGE, Json::nullValue, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by Json::FastWriter::writeValue(), Json::StyledWriter::writeValue(), and Json::StyledStreamWriter::writeValue()\&.
.SS "const char * Json::Value::asCString () const"

.PP
References JSON_ASSERT_MESSAGE, Json::Value::ValueHolder::string_, Json::stringValue, type_, and value_\&.
.PP
Referenced by Json::FastWriter::writeValue(), Json::StyledWriter::writeValue(), and Json::StyledStreamWriter::writeValue()\&.
.SS "double Json::Value::asDouble () const"

.PP
References Json::Value::ValueHolder::bool_, Json::booleanValue, Json::Value::ValueHolder::int_, Json::intValue, JSON_FAIL_MESSAGE, Json::nullValue, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by isConvertibleTo(), Json::FastWriter::writeValue(), Json::StyledWriter::writeValue(), and Json::StyledStreamWriter::writeValue()\&.
.SS "float Json::Value::asFloat () const"

.PP
References Json::Value::ValueHolder::bool_, Json::booleanValue, Json::Value::ValueHolder::int_, Json::intValue, JSON_FAIL_MESSAGE, Json::nullValue, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.SS "\fBValue::Int\fP Json::Value::asInt () const"

.PP
References Json::Value::ValueHolder::bool_, Json::booleanValue, Json::InRange(), Json::Value::ValueHolder::int_, Json::intValue, isInt(), JSON_ASSERT_MESSAGE, JSON_FAIL_MESSAGE, maxInt, minInt, Json::nullValue, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by asLargestInt()\&.
.SS "\fBValue::Int64\fP Json::Value::asInt64 () const"

.PP
References Json::Value::ValueHolder::bool_, Json::booleanValue, Json::InRange(), Json::Value::ValueHolder::int_, Json::intValue, isInt64(), JSON_ASSERT_MESSAGE, JSON_FAIL_MESSAGE, maxInt64, minInt64, Json::nullValue, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by asLargestInt()\&.
.SS "\fBLargestInt\fP Json::Value::asLargestInt () const"

.PP
References asInt(), and asInt64()\&.
.PP
Referenced by Json::FastWriter::writeValue(), Json::StyledWriter::writeValue(), and Json::StyledStreamWriter::writeValue()\&.
.SS "\fBLargestUInt\fP Json::Value::asLargestUInt () const"

.PP
References asUInt(), and asUInt64()\&.
.PP
Referenced by Json::FastWriter::writeValue(), Json::StyledWriter::writeValue(), and Json::StyledStreamWriter::writeValue()\&.
.SS "std::string Json::Value::asString () const"

.PP
References Json::Value::ValueHolder::bool_, Json::booleanValue, Json::Value::ValueHolder::int_, Json::intValue, JSON_FAIL_MESSAGE, Json::nullValue, Json::Value::ValueHolder::real_, Json::realValue, Json::Value::ValueHolder::string_, Json::stringValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, value_, and Json::valueToString()\&.
.PP
Referenced by isConvertibleTo(), and Json::Reader::readObject()\&.
.SS "\fBValue::UInt\fP Json::Value::asUInt () const"

.PP
References Json::Value::ValueHolder::bool_, Json::booleanValue, Json::InRange(), Json::Value::ValueHolder::int_, Json::intValue, isUInt(), JSON_ASSERT_MESSAGE, JSON_FAIL_MESSAGE, maxUInt, Json::nullValue, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by asLargestUInt()\&.
.SS "\fBValue::UInt64\fP Json::Value::asUInt64 () const"

.PP
References Json::Value::ValueHolder::bool_, Json::booleanValue, Json::InRange(), Json::Value::ValueHolder::int_, Json::intValue, isUInt64(), JSON_ASSERT_MESSAGE, JSON_FAIL_MESSAGE, maxUInt64, Json::nullValue, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by asLargestUInt()\&.
.SS "\fBValue::const_iterator\fP Json::Value::begin () const"

.PP
References Json::arrayValue, Json::Value::ValueHolder::map_, Json::objectValue, type_, and value_\&.
.SS "\fBValue::iterator\fP Json::Value::begin ()"

.PP
References Json::arrayValue, Json::Value::ValueHolder::map_, Json::objectValue, type_, and value_\&.
.SS "void Json::Value::clear ()"
Remove all object members and array elements\&. 
.PP
\fBPrecondition:\fP
.RS 4
\fBtype()\fP is arrayValue, objectValue, or nullValue 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fBtype()\fP is unchanged 
.RE
.PP

.PP
References Json::arrayValue, JSON_ASSERT_MESSAGE, limit_, Json::Value::ValueHolder::map_, Json::nullValue, Json::objectValue, start_, type_, and value_\&.
.PP
Referenced by resize()\&.
.SS "int Json::Value::compare (const \fBValue\fP &other) const"

.SS "bool Json::Value::empty () const"

.PP
Return true if empty array, empty object, or null; otherwise, false\&. 
.PP
References isArray(), isNull(), isObject(), and size()\&.
.SS "\fBValue::const_iterator\fP Json::Value::end () const"

.PP
References Json::arrayValue, Json::Value::ValueHolder::map_, Json::objectValue, type_, and value_\&.
.SS "\fBValue::iterator\fP Json::Value::end ()"

.PP
References Json::arrayValue, Json::Value::ValueHolder::map_, Json::objectValue, type_, and value_\&.
.SS "\fBValue\fP Json::Value::get (\fBArrayIndex\fPindex, const \fBValue\fP &defaultValue) const"
If the array contains at least index+1 elements, returns the element value, otherwise returns defaultValue\&. 
.PP
References null\&.
.SS "\fBValue\fP Json::Value::get (const char *key, const \fBValue\fP &defaultValue) const"

.PP
Return the member named key if it exist, defaultValue otherwise\&. 
.PP
References null\&.
.SS "\fBValue\fP Json::Value::get (const std::string &key, const \fBValue\fP &defaultValue) const"

.PP
Return the member named key if it exist, defaultValue otherwise\&. 
.SS "std::string Json::Value::getComment (\fBCommentPlacement\fPplacement) const"

.PP
Include delimiters and embedded newlines\&. 
.PP
References Json::Value::CommentInfo::comment_, comments_, and hasComment()\&.
.PP
Referenced by Json::StyledWriter::writeCommentAfterValueOnSameLine(), Json::StyledStreamWriter::writeCommentAfterValueOnSameLine(), Json::StyledWriter::writeCommentBeforeValue(), and Json::StyledStreamWriter::writeCommentBeforeValue()\&.
.SS "\fBValue::Members\fP Json::Value::getMemberNames () const"

.PP
Return a list of the member names\&. If null, return an empty list\&. 
.PP
\fBPrecondition:\fP
.RS 4
\fBtype()\fP is objectValue or nullValue 
.RE
.PP
\fBPostcondition:\fP
.RS 4
if \fBtype()\fP was nullValue, it remains nullValue 
.RE
.PP

.PP
References JSON_ASSERT_MESSAGE, Json::Value::ValueHolder::map_, Json::nullValue, Json::objectValue, type_, and value_\&.
.PP
Referenced by Json::FastWriter::writeValue(), Json::StyledWriter::writeValue(), and Json::StyledStreamWriter::writeValue()\&.
.SS "size_t Json::Value::getOffsetLimit () const"

.PP
References limit_\&.
.SS "size_t Json::Value::getOffsetStart () const"

.PP
References start_\&.
.SS "bool Json::Value::hasComment (\fBCommentPlacement\fPplacement) const"

.PP
References Json::Value::CommentInfo::comment_, and comments_\&.
.PP
Referenced by getComment(), Json::StyledWriter::hasCommentForValue(), Json::StyledStreamWriter::hasCommentForValue(), Json::StyledWriter::writeCommentAfterValueOnSameLine(), Json::StyledStreamWriter::writeCommentAfterValueOnSameLine(), Json::StyledWriter::writeCommentBeforeValue(), and Json::StyledStreamWriter::writeCommentBeforeValue()\&.
.SS "bool Json::Value::isArray () const"

.PP
References Json::arrayValue, and type_\&.
.PP
Referenced by empty(), Json::StyledWriter::isMultineArray(), Json::StyledStreamWriter::isMultineArray(), Json::Path::make(), Json::Reader::parse(), and Json::Path::resolve()\&.
.SS "bool Json::Value::isBool () const"

.PP
References Json::booleanValue, and type_\&.
.SS "bool Json::Value::isConvertibleTo (\fBValueType\fPother) const"

.PP
References Json::arrayValue, asDouble(), asString(), Json::Value::ValueHolder::bool_, Json::booleanValue, Json::InRange(), Json::intValue, isInt(), isNumeric(), isUInt(), JSON_ASSERT_UNREACHABLE, Json::Value::ValueHolder::map_, maxInt, maxUInt, minInt, Json::nullValue, Json::objectValue, Json::Value::ValueHolder::real_, Json::realValue, Json::stringValue, type_, Json::uintValue, and value_\&.
.SS "bool Json::Value::isDouble () const"

.PP
References isIntegral(), Json::realValue, and type_\&.
.PP
Referenced by isNumeric()\&.
.SS "bool Json::Value::isInt () const"

.PP
References Json::Value::ValueHolder::int_, Json::intValue, Json::IsIntegral(), maxInt, minInt, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by asInt(), isConvertibleTo(), and isIntegral()\&.
.SS "bool Json::Value::isInt64 () const"

.PP
References Json::intValue, Json::IsIntegral(), maxInt64, minInt64, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by asInt64(), and isIntegral()\&.
.SS "bool Json::Value::isIntegral () const"

.PP
References isInt(), isInt64(), isUInt(), and isUInt64()\&.
.PP
Referenced by isDouble(), and isNumeric()\&.
.SS "bool Json::Value::isMember (const char *key) const"

.PP
Return true if the object has a member named key\&. 
.PP
References null\&.
.PP
Referenced by isMember()\&.
.SS "bool Json::Value::isMember (const std::string &key) const"

.PP
Return true if the object has a member named key\&. 
.PP
References isMember()\&.
.SS "bool Json::Value::isNull () const"

.PP
References Json::nullValue, and type_\&.
.PP
Referenced by empty(), and operator!()\&.
.SS "bool Json::Value::isNumeric () const"

.PP
References isDouble(), and isIntegral()\&.
.PP
Referenced by isConvertibleTo()\&.
.SS "bool Json::Value::isObject () const"

.PP
References Json::objectValue, and type_\&.
.PP
Referenced by empty(), Json::StyledWriter::isMultineArray(), Json::StyledStreamWriter::isMultineArray(), Json::Path::make(), Json::Reader::parse(), and Json::Path::resolve()\&.
.SS "bool Json::Value::isString () const"

.PP
References Json::stringValue, and type_\&.
.SS "bool Json::Value::isUInt () const"

.PP
References Json::Value::ValueHolder::int_, Json::intValue, Json::IsIntegral(), maxUInt, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.PP
Referenced by asUInt(), isConvertibleTo(), and isIntegral()\&.
.SS "bool Json::Value::isUInt64 () const"

.PP
References Json::Value::ValueHolder::int_, Json::intValue, Json::IsIntegral(), Json::maxUInt64AsDouble, Json::Value::ValueHolder::real_, Json::realValue, type_, Json::uintValue, and value_\&.
.PP
Referenced by asUInt64(), and isIntegral()\&.
.SS "bool Json::Value::isValidIndex (\fBArrayIndex\fPindex) const"

.PP
Return true if index < \fBsize()\fP\&. 
.PP
References size()\&.
.PP
Referenced by Json::Path::resolve()\&.
.SS "bool Json::Value::operator! () const"

.PP
Return \fBisNull()\fP 
.PP
References isNull()\&.
.SS "bool \fBJson::Value::operator!\fP= (const \fBValue\fP &other) const"

.SS "bool Json::Value::operator< (const \fBValue\fP &other) const"

.PP
References Json::arrayValue, Json::Value::ValueHolder::bool_, Json::booleanValue, Json::Value::ValueHolder::int_, Json::intValue, JSON_ASSERT_UNREACHABLE, Json::Value::ValueHolder::map_, Json::nullValue, Json::objectValue, Json::Value::ValueHolder::real_, Json::realValue, Json::Value::ValueHolder::string_, Json::stringValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.SS "bool Json::Value::operator<= (const \fBValue\fP &other) const"

.SS "\fBValue\fP & Json::Value::operator= (\fBValue\fPother)"

.PP
References swap()\&.
.SS "bool Json::Value::operator== (const \fBValue\fP &other) const"

.PP
References Json::arrayValue, Json::Value::ValueHolder::bool_, Json::booleanValue, Json::Value::ValueHolder::int_, Json::intValue, JSON_ASSERT_UNREACHABLE, Json::Value::ValueHolder::map_, Json::nullValue, Json::objectValue, Json::Value::ValueHolder::real_, Json::realValue, Json::Value::ValueHolder::string_, Json::stringValue, type_, Json::Value::ValueHolder::uint_, Json::uintValue, and value_\&.
.SS "bool Json::Value::operator> (const \fBValue\fP &other) const"

.SS "bool Json::Value::operator>= (const \fBValue\fP &other) const"

.SS "\fBValue\fP & Json::Value::operator[] (\fBArrayIndex\fPindex)"
Access an array element (zero based index )\&. If the array contains less than index element, then null value are inserted in the array so that its size is index+1\&. (You may need to say 'value[0u]' to get your compiler to distinguish this from the operator[] which takes a string\&.) 
.PP
References Json::arrayValue, JSON_ASSERT_MESSAGE, Json::Value::ValueHolder::map_, null, Json::nullValue, type_, Value(), and value_\&.
.SS "\fBValue\fP & Json::Value::operator[] (intindex)"
Access an array element (zero based index )\&. If the array contains less than index element, then null value are inserted in the array so that its size is index+1\&. (You may need to say 'value[0u]' to get your compiler to distinguish this from the operator[] which takes a string\&.) 
.PP
References JSON_ASSERT_MESSAGE\&.
.SS "const \fBValue\fP & Json::Value::operator[] (\fBArrayIndex\fPindex) const"
Access an array element (zero based index ) (You may need to say 'value[0u]' to get your compiler to distinguish this from the operator[] which takes a string\&.) 
.PP
References Json::arrayValue, JSON_ASSERT_MESSAGE, Json::Value::ValueHolder::map_, null, Json::nullValue, type_, and value_\&.
.SS "const \fBValue\fP & Json::Value::operator[] (intindex) const"
Access an array element (zero based index ) (You may need to say 'value[0u]' to get your compiler to distinguish this from the operator[] which takes a string\&.) 
.PP
References JSON_ASSERT_MESSAGE\&.
.SS "\fBValue\fP & Json::Value::operator[] (const char *key)"

.PP
Access an object value by name, create a null member if it does not exist\&. 
.PP
References resolveReference()\&.
.SS "const \fBValue\fP & Json::Value::operator[] (const char *key) const"
Access an object value by name, returns null if there is no member with that name\&. 
.PP
References JSON_ASSERT_MESSAGE, Json::Value::ValueHolder::map_, Json::Value::CZString::noDuplication, null, Json::nullValue, Json::objectValue, type_, and value_\&.
.SS "\fBValue\fP & Json::Value::operator[] (const std::string &key)"

.PP
Access an object value by name, create a null member if it does not exist\&. 
.SS "const \fBValue\fP & Json::Value::operator[] (const std::string &key) const"
Access an object value by name, returns null if there is no member with that name\&. 
.SS "\fBValue\fP & Json::Value::operator[] (const \fBStaticString\fP &key)"

.PP
Access an object value by name, create a null member if it does not exist\&. If the object as no entry for that name, then the member name used to store the new entry is not duplicated\&. Example of use: 
.PP
.nf
* Json::Value object;
* static const StaticString code("code");
* object[code] = 1234;
* 

.fi
.PP
 
.PP
References resolveReference()\&.
.SS "\fBValue\fP Json::Value::removeMember (const char *key)"

.PP
Remove and return the named member\&. Do nothing if it did not exist\&. 
.PP
\fBReturns:\fP
.RS 4
the removed \fBValue\fP, or null\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fBtype()\fP is objectValue or nullValue 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fBtype()\fP is unchanged 
.RE
.PP

.PP
References JSON_ASSERT_MESSAGE, Json::Value::ValueHolder::map_, Json::Value::CZString::noDuplication, null, Json::nullValue, Json::objectValue, type_, and value_\&.
.PP
Referenced by removeMember()\&.
.SS "\fBValue\fP Json::Value::removeMember (const std::string &key)"

.PP
Same as \fBremoveMember(const char*)\fP 
.PP
References removeMember()\&.
.SS "void Json::Value::resize (\fBArrayIndex\fPsize)"
Resize the array to size elements\&. New elements are initialized to null\&. May only be called on nullValue or arrayValue\&. 
.PP
\fBPrecondition:\fP
.RS 4
\fBtype()\fP is arrayValue or nullValue 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fBtype()\fP is arrayValue 
.RE
.PP

.PP
References Json::arrayValue, clear(), JSON_ASSERT_MESSAGE, Json::Value::ValueHolder::map_, Json::nullValue, size(), type_, Value(), and value_\&.
.SS "\fBValue\fP & Json::Value::resolveReference (const char *key, boolisStatic)\fC [private]\fP"

.PP
References Json::Value::CZString::duplicateOnCopy, JSON_ASSERT_MESSAGE, Json::Value::ValueHolder::map_, Json::Value::CZString::noDuplication, null, Json::nullValue, Json::objectValue, type_, Value(), and value_\&.
.PP
Referenced by operator[]()\&.
.SS "void Json::Value::setComment (const char *comment, \fBCommentPlacement\fPplacement)"

.PP
Comments must be //\&.\&.\&. or /* \&.\&.\&. */\&. 
.PP
References comments_, Json::numberOfCommentPlacement, and Json::Value::CommentInfo::setComment()\&.
.PP
Referenced by Json::Reader::addComment(), Json::Reader::parse(), Json::Reader::readValue(), and setComment()\&.
.SS "void Json::Value::setComment (const std::string &comment, \fBCommentPlacement\fPplacement)"

.PP
Comments must be //\&.\&.\&. or /* \&.\&.\&. */\&. 
.PP
References setComment()\&.
.SS "void Json::Value::setOffsetLimit (size_tlimit)"

.PP
References limit_\&.
.PP
Referenced by Json::Reader::decodeDouble(), Json::Reader::decodeNumber(), Json::Reader::decodeString(), and Json::Reader::readValue()\&.
.SS "void Json::Value::setOffsetStart (size_tstart)"

.PP
References start_\&.
.PP
Referenced by Json::Reader::decodeDouble(), Json::Reader::decodeNumber(), Json::Reader::decodeString(), Json::Reader::readArray(), Json::Reader::readObject(), and Json::Reader::readValue()\&.
.SS "\fBArrayIndex\fP Json::Value::size () const"

.PP
Number of values in array or object\&. 
.PP
References Json::arrayValue, Json::booleanValue, Json::intValue, JSON_ASSERT_UNREACHABLE, Json::Value::ValueHolder::map_, Json::nullValue, Json::objectValue, Json::realValue, Json::stringValue, type_, Json::uintValue, and value_\&.
.PP
Referenced by append(), empty(), Json::StyledWriter::isMultineArray(), Json::StyledStreamWriter::isMultineArray(), isValidIndex(), resize(), Json::StyledWriter::writeArrayValue(), Json::StyledStreamWriter::writeArrayValue(), and Json::FastWriter::writeValue()\&.
.SS "void Json::Value::swap (\fBValue\fP &other)"
Swap values\&. 
.PP
\fBNote:\fP
.RS 4
Currently, comments are intentionally not swapped, for both logic and efficiency\&. 
.RE
.PP

.PP
References allocated_, limit_, start_, type_, and value_\&.
.PP
Referenced by Json::Value::CZString::operator=(), and operator=()\&.
.SS "std::string Json::Value::toStyledString () const"

.PP
References Json::StyledWriter::write()\&.
.SS "\fBValueType\fP Json::Value::type () const"

.PP
References type_\&.
.PP
Referenced by Json::FastWriter::writeValue(), Json::StyledWriter::writeValue(), and Json::StyledStreamWriter::writeValue()\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBValueIteratorBase\fP\fC [friend]\fP"

.SH "Member Data Documentation"
.PP 
.SS "int Json::Value::allocated_\fC [private]\fP"

.PP
Referenced by swap(), Value(), and ~Value()\&.
.SS "\fBCommentInfo\fP* Json::Value::comments_\fC [private]\fP"

.PP
Referenced by getComment(), hasComment(), setComment(), Value(), and ~Value()\&.
.SS "size_t Json::Value::limit_\fC [private]\fP"

.PP
Referenced by clear(), getOffsetLimit(), setOffsetLimit(), and swap()\&.
.SS "const \fBInt\fP Json::Value::maxInt = \fBInt\fP(\fBUInt\fP(-1) / 2)\fC [static]\fP"

.PP
Maximum signed int value that can be stored in a \fBJson::Value\fP\&. 
.PP
Referenced by asInt(), Json::Reader::decodeNumber(), Json::duplicateStringValue(), isConvertibleTo(), and isInt()\&.
.SS "const \fBInt64\fP Json::Value::maxInt64 = \fBInt64\fP(\fBUInt64\fP(-1) / 2)\fC [static]\fP"

.PP
Maximum signed 64 bits int value that can be stored in a \fBJson::Value\fP\&. 
.PP
Referenced by asInt64(), and isInt64()\&.
.SS "const \fBLargestInt\fP Json::Value::maxLargestInt = \fBLargestInt\fP(\fBLargestUInt\fP(-1) / 2)\fC [static]\fP"

.PP
Maximum signed integer value that can be stored in a \fBJson::Value\fP\&. 
.SS "const \fBLargestUInt\fP Json::Value::maxLargestUInt = \fBLargestUInt\fP(-1)\fC [static]\fP"

.PP
Maximum unsigned integer value that can be stored in a \fBJson::Value\fP\&. 
.PP
Referenced by Json::Reader::decodeNumber()\&.
.SS "const \fBUInt\fP Json::Value::maxUInt = \fBUInt\fP(-1)\fC [static]\fP"

.PP
Maximum unsigned int value that can be stored in a \fBJson::Value\fP\&. 
.PP
Referenced by asUInt(), isConvertibleTo(), and isUInt()\&.
.SS "const \fBUInt64\fP Json::Value::maxUInt64 = \fBUInt64\fP(-1)\fC [static]\fP"

.PP
Maximum unsigned 64 bits int value that can be stored in a \fBJson::Value\fP\&. 
.PP
Referenced by asUInt64()\&.
.SS "const \fBInt\fP Json::Value::minInt = \fBInt\fP(~(\fBUInt\fP(-1) / 2))\fC [static]\fP"

.PP
Minimum signed int value that can be stored in a \fBJson::Value\fP\&. 
.PP
Referenced by asInt(), isConvertibleTo(), and isInt()\&.
.SS "const \fBInt64\fP Json::Value::minInt64 = \fBInt64\fP(~(\fBUInt64\fP(-1) / 2))\fC [static]\fP"

.PP
Minimum signed 64 bits int value that can be stored in a \fBJson::Value\fP\&. 
.PP
Referenced by asInt64(), and isInt64()\&.
.SS "const \fBLargestInt\fP Json::Value::minLargestInt = \fBLargestInt\fP(~(\fBLargestUInt\fP(-1) / 2))\fC [static]\fP"

.PP
Minimum signed integer value that can be stored in a \fBJson::Value\fP\&. 
.PP
Referenced by Json::Reader::decodeNumber()\&.
.SS "const \fBValue\fP & Json::Value::null = reinterpret_cast<const \fBValue\fP&>(\fBkNullRef\fP)\fC [static]\fP"

.PP
Referenced by get(), isMember(), operator[](), removeMember(), Json::Path::resolve(), and resolveReference()\&.
.SS "size_t Json::Value::start_\fC [private]\fP"

.PP
Referenced by clear(), getOffsetStart(), setOffsetStart(), and swap()\&.
.SS "\fBValueType\fP Json::Value::type_\fC [private]\fP"

.PP
Referenced by asBool(), asCString(), asDouble(), asFloat(), asInt(), asInt64(), asString(), asUInt(), asUInt64(), begin(), clear(), end(), getMemberNames(), isArray(), isBool(), isConvertibleTo(), isDouble(), isInt(), isInt64(), isNull(), isObject(), isString(), isUInt(), isUInt64(), operator<(), operator==(), operator[](), removeMember(), resize(), resolveReference(), size(), swap(), type(), Value(), and ~Value()\&.
.SS "union \fBJson::Value::ValueHolder\fP  Json::Value::value_\fC [private]\fP"

.PP
Referenced by asBool(), asCString(), asDouble(), asFloat(), asInt(), asInt64(), asString(), asUInt(), asUInt64(), begin(), clear(), end(), getMemberNames(), isConvertibleTo(), isInt(), isInt64(), isUInt(), isUInt64(), operator<(), operator==(), operator[](), removeMember(), resize(), resolveReference(), size(), swap(), Value(), and ~Value()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Claims from the source code\&.
