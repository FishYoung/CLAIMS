.TH "Json::Reader" 3 "Thu Nov 12 2015" "Claims" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Json::Reader \- 
.PP
Unserialize a \fCJSON\fP document into a \fBValue\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <json\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBErrorInfo\fP"
.br
.ti -1c
.RI "struct \fBStructuredError\fP"
.br
.RI "\fIAn error tagged with where in the JSON text it was encountered\&. \fP"
.ti -1c
.RI "class \fBToken\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef char \fBChar\fP"
.br
.ti -1c
.RI "typedef const \fBChar\fP * \fBLocation\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBReader\fP ()"
.br
.RI "\fIConstructs a \fBReader\fP allowing all features for parsing\&. \fP"
.ti -1c
.RI "\fBReader\fP (const \fBFeatures\fP &features)"
.br
.RI "\fIConstructs a \fBReader\fP allowing the specified feature set for parsing\&. \fP"
.ti -1c
.RI "bool \fBparse\fP (const std::string &document, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "\fIRead a \fBValue\fP from a \fCJSON\fP document\&. \fP"
.ti -1c
.RI "bool \fBparse\fP (const char *beginDoc, const char *endDoc, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "\fIRead a \fBValue\fP from a \fCJSON\fP document\&. \fP"
.ti -1c
.RI "bool \fBparse\fP (std::istream &is, \fBValue\fP &root, bool collectComments=true)"
.br
.RI "\fIParse from input stream\&. \fP"
.ti -1c
.RI "std::string \fBgetFormatedErrorMessages\fP () const "
.br
.RI "\fIReturns a user friendly string that list errors in the parsed document\&. \fP"
.ti -1c
.RI "std::string \fBgetFormattedErrorMessages\fP () const "
.br
.RI "\fIReturns a user friendly string that list errors in the parsed document\&. \fP"
.ti -1c
.RI "std::vector< \fBStructuredError\fP > \fBgetStructuredErrors\fP () const "
.br
.RI "\fIReturns a vector of structured erros encounted while parsing\&. \fP"
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBTokenType\fP { \fBtokenEndOfStream\fP = 0, \fBtokenObjectBegin\fP, \fBtokenObjectEnd\fP, \fBtokenArrayBegin\fP, \fBtokenArrayEnd\fP, \fBtokenString\fP, \fBtokenNumber\fP, \fBtokenTrue\fP, \fBtokenFalse\fP, \fBtokenNull\fP, \fBtokenArraySeparator\fP, \fBtokenMemberSeparator\fP, \fBtokenComment\fP, \fBtokenError\fP }"
.br
.ti -1c
.RI "typedef std::deque< \fBErrorInfo\fP > \fBErrors\fP"
.br
.ti -1c
.RI "typedef std::stack< \fBValue\fP * > \fBNodes\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "bool \fBexpectToken\fP (\fBTokenType\fP type, \fBToken\fP &token, const char *message)"
.br
.ti -1c
.RI "bool \fBreadToken\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "void \fBskipSpaces\fP ()"
.br
.ti -1c
.RI "bool \fBmatch\fP (\fBLocation\fP pattern, int patternLength)"
.br
.ti -1c
.RI "bool \fBreadComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadCStyleComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadCppStyleComment\fP ()"
.br
.ti -1c
.RI "bool \fBreadString\fP ()"
.br
.ti -1c
.RI "void \fBreadNumber\fP ()"
.br
.ti -1c
.RI "bool \fBreadValue\fP ()"
.br
.ti -1c
.RI "bool \fBreadObject\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBreadArray\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeNumber\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeNumber\fP (\fBToken\fP &token, \fBValue\fP &decoded)"
.br
.ti -1c
.RI "bool \fBdecodeString\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeString\fP (\fBToken\fP &token, std::string &decoded)"
.br
.ti -1c
.RI "bool \fBdecodeDouble\fP (\fBToken\fP &token)"
.br
.ti -1c
.RI "bool \fBdecodeDouble\fP (\fBToken\fP &token, \fBValue\fP &decoded)"
.br
.ti -1c
.RI "bool \fBdecodeUnicodeCodePoint\fP (\fBToken\fP &token, \fBLocation\fP &current, \fBLocation\fP end, unsigned int &unicode)"
.br
.ti -1c
.RI "bool \fBdecodeUnicodeEscapeSequence\fP (\fBToken\fP &token, \fBLocation\fP &current, \fBLocation\fP end, unsigned int &unicode)"
.br
.ti -1c
.RI "bool \fBaddError\fP (const std::string &message, \fBToken\fP &token, \fBLocation\fP extra=0)"
.br
.ti -1c
.RI "bool \fBrecoverFromError\fP (\fBTokenType\fP skipUntilToken)"
.br
.ti -1c
.RI "bool \fBaddErrorAndRecover\fP (const std::string &message, \fBToken\fP &token, \fBTokenType\fP skipUntilToken)"
.br
.ti -1c
.RI "void \fBskipUntilSpace\fP ()"
.br
.ti -1c
.RI "\fBValue\fP & \fBcurrentValue\fP ()"
.br
.ti -1c
.RI "\fBChar\fP \fBgetNextChar\fP ()"
.br
.ti -1c
.RI "void \fBgetLocationLineAndColumn\fP (\fBLocation\fP location, int &line, int &column) const "
.br
.ti -1c
.RI "std::string \fBgetLocationLineAndColumn\fP (\fBLocation\fP location) const "
.br
.ti -1c
.RI "void \fBaddComment\fP (\fBLocation\fP begin, \fBLocation\fP end, \fBCommentPlacement\fP placement)"
.br
.ti -1c
.RI "void \fBskipCommentTokens\fP (\fBToken\fP &token)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBNodes\fP \fBnodes_\fP"
.br
.ti -1c
.RI "\fBErrors\fP \fBerrors_\fP"
.br
.ti -1c
.RI "std::string \fBdocument_\fP"
.br
.ti -1c
.RI "\fBLocation\fP \fBbegin_\fP"
.br
.ti -1c
.RI "\fBLocation\fP \fBend_\fP"
.br
.ti -1c
.RI "\fBLocation\fP \fBcurrent_\fP"
.br
.ti -1c
.RI "\fBLocation\fP \fBlastValueEnd_\fP"
.br
.ti -1c
.RI "\fBValue\fP * \fBlastValue_\fP"
.br
.ti -1c
.RI "std::string \fBcommentsBefore_\fP"
.br
.ti -1c
.RI "\fBFeatures\fP \fBfeatures_\fP"
.br
.ti -1c
.RI "bool \fBcollectComments_\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Unserialize a \fCJSON\fP document into a \fBValue\fP\&. 


.SH "Member Typedef Documentation"
.PP 
.SS "typedef char \fBJson::Reader::Char\fP"

.SS "typedef std::deque<\fBErrorInfo\fP> \fBJson::Reader::Errors\fP\fC [private]\fP"

.SS "typedef const \fBChar\fP* \fBJson::Reader::Location\fP"

.SS "typedef std::stack<\fBValue\fP*> \fBJson::Reader::Nodes\fP\fC [private]\fP"

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBJson::Reader::TokenType\fP\fC [private]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fItokenEndOfStream \fP\fP
.TP
\fB\fItokenObjectBegin \fP\fP
.TP
\fB\fItokenObjectEnd \fP\fP
.TP
\fB\fItokenArrayBegin \fP\fP
.TP
\fB\fItokenArrayEnd \fP\fP
.TP
\fB\fItokenString \fP\fP
.TP
\fB\fItokenNumber \fP\fP
.TP
\fB\fItokenTrue \fP\fP
.TP
\fB\fItokenFalse \fP\fP
.TP
\fB\fItokenNull \fP\fP
.TP
\fB\fItokenArraySeparator \fP\fP
.TP
\fB\fItokenMemberSeparator \fP\fP
.TP
\fB\fItokenComment \fP\fP
.TP
\fB\fItokenError \fP\fP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Json::Reader::Reader ()"

.PP
Constructs a \fBReader\fP allowing all features for parsing\&. 
.SS "Json::Reader::Reader (const \fBFeatures\fP &features)"

.PP
Constructs a \fBReader\fP allowing the specified feature set for parsing\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Json::Reader::addComment (\fBLocation\fPbegin, \fBLocation\fPend, \fBCommentPlacement\fPplacement)\fC [private]\fP"

.PP
References collectComments_, Json::commentAfterOnSameLine, commentsBefore_, lastValue_, and Json::Value::setComment()\&.
.PP
Referenced by readComment()\&.
.SS "bool Json::Reader::addError (const std::string &message, \fBToken\fP &token, \fBLocation\fPextra = \fC0\fP)\fC [private]\fP"

.PP
References errors_, Json::Reader::ErrorInfo::extra_, Json::Reader::ErrorInfo::message_, and Json::Reader::ErrorInfo::token_\&.
.PP
Referenced by addErrorAndRecover(), decodeDouble(), decodeNumber(), decodeString(), decodeUnicodeCodePoint(), decodeUnicodeEscapeSequence(), expectToken(), parse(), and readValue()\&.
.SS "bool Json::Reader::addErrorAndRecover (const std::string &message, \fBToken\fP &token, \fBTokenType\fPskipUntilToken)\fC [private]\fP"

.PP
References addError(), and recoverFromError()\&.
.PP
Referenced by readArray(), and readObject()\&.
.SS "\fBValue\fP & Json::Reader::currentValue ()\fC [private]\fP"

.PP
References nodes_\&.
.PP
Referenced by decodeDouble(), decodeNumber(), decodeString(), readArray(), readObject(), and readValue()\&.
.SS "bool Json::Reader::decodeDouble (\fBToken\fP &token)\fC [private]\fP"

.PP
References begin_, currentValue(), Json::Reader::Token::end_, Json::Value::setOffsetLimit(), Json::Value::setOffsetStart(), and Json::Reader::Token::start_\&.
.PP
Referenced by decodeNumber()\&.
.SS "bool Json::Reader::decodeDouble (\fBToken\fP &token, \fBValue\fP &decoded)\fC [private]\fP"

.PP
References addError(), Json::Reader::Token::end_, and Json::Reader::Token::start_\&.
.SS "bool Json::Reader::decodeNumber (\fBToken\fP &token)\fC [private]\fP"

.PP
References begin_, currentValue(), Json::Reader::Token::end_, Json::Value::setOffsetLimit(), Json::Value::setOffsetStart(), and Json::Reader::Token::start_\&.
.PP
Referenced by readObject(), and readValue()\&.
.SS "bool Json::Reader::decodeNumber (\fBToken\fP &token, \fBValue\fP &decoded)\fC [private]\fP"

.PP
References addError(), decodeDouble(), Json::Reader::Token::end_, Json::in(), Json::Value::maxInt, Json::Value::maxLargestUInt, Json::Value::minLargestInt, and Json::Reader::Token::start_\&.
.SS "bool Json::Reader::decodeString (\fBToken\fP &token)\fC [private]\fP"

.PP
References begin_, currentValue(), Json::Reader::Token::end_, Json::Value::setOffsetLimit(), Json::Value::setOffsetStart(), and Json::Reader::Token::start_\&.
.PP
Referenced by readObject(), and readValue()\&.
.SS "bool Json::Reader::decodeString (\fBToken\fP &token, std::string &decoded)\fC [private]\fP"

.PP
References addError(), Json::codePointToUTF8(), decodeUnicodeCodePoint(), Json::Reader::Token::end_, and Json::Reader::Token::start_\&.
.SS "bool Json::Reader::decodeUnicodeCodePoint (\fBToken\fP &token, \fBLocation\fP &current, \fBLocation\fPend, unsigned int &unicode)\fC [private]\fP"

.PP
References addError(), and decodeUnicodeEscapeSequence()\&.
.PP
Referenced by decodeString()\&.
.SS "bool Json::Reader::decodeUnicodeEscapeSequence (\fBToken\fP &token, \fBLocation\fP &current, \fBLocation\fPend, unsigned int &unicode)\fC [private]\fP"

.PP
References addError()\&.
.PP
Referenced by decodeUnicodeCodePoint()\&.
.SS "bool Json::Reader::expectToken (\fBTokenType\fPtype, \fBToken\fP &token, const char *message)\fC [private]\fP"

.PP
References addError(), readToken(), and Json::Reader::Token::type_\&.
.SS "std::string Json::Reader::getFormatedErrorMessages () const"

.PP
Returns a user friendly string that list errors in the parsed document\&. 
.PP
\fBReturns:\fP
.RS 4
Formatted error message with the list of errors with their location in the parsed document\&. An empty string is returned if no error occurred during parsing\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use \fBgetFormattedErrorMessages()\fP instead (typo fix)\&. 
.RE
.PP

.PP
References getFormattedErrorMessages()\&.
.SS "std::string Json::Reader::getFormattedErrorMessages () const"

.PP
Returns a user friendly string that list errors in the parsed document\&. 
.PP
\fBReturns:\fP
.RS 4
Formatted error message with the list of errors with their location in the parsed document\&. An empty string is returned if no error occurred during parsing\&. 
.RE
.PP

.PP
References errors_, Json::Reader::ErrorInfo::extra_, getLocationLineAndColumn(), Json::Reader::ErrorInfo::message_, Json::Reader::Token::start_, and Json::Reader::ErrorInfo::token_\&.
.PP
Referenced by getFormatedErrorMessages(), and Json::operator>>()\&.
.SS "void Json::Reader::getLocationLineAndColumn (\fBLocation\fPlocation, int &line, int &column) const\fC [private]\fP"

.PP
References begin_, and end_\&.
.PP
Referenced by getFormattedErrorMessages(), and getLocationLineAndColumn()\&.
.SS "std::string Json::Reader::getLocationLineAndColumn (\fBLocation\fPlocation) const\fC [private]\fP"

.PP
References getLocationLineAndColumn()\&.
.SS "\fBReader::Char\fP Json::Reader::getNextChar ()\fC [private]\fP"

.PP
References current_, and end_\&.
.PP
Referenced by readComment(), readCppStyleComment(), readCStyleComment(), readString(), and readToken()\&.
.SS "std::vector< \fBReader::StructuredError\fP > Json::Reader::getStructuredErrors () const"

.PP
Returns a vector of structured erros encounted while parsing\&. 
.PP
\fBReturns:\fP
.RS 4
A (possibly empty) vector of \fBStructuredError\fP objects\&. Currently only one error can be returned, but the caller should tolerate multiple errors\&. This can occur if the parser recovers from a non-fatal parse error and then encounters additional errors\&. 
.RE
.PP

.PP
References begin_, Json::Reader::Token::end_, errors_, Json::Reader::StructuredError::message, Json::Reader::ErrorInfo::message_, Json::Reader::StructuredError::offset_limit, Json::Reader::StructuredError::offset_start, Json::Reader::Token::start_, and Json::Reader::ErrorInfo::token_\&.
.SS "bool Json::Reader::match (\fBLocation\fPpattern, intpatternLength)\fC [private]\fP"

.PP
References current_, and end_\&.
.PP
Referenced by readToken()\&.
.SS "bool Json::Reader::parse (const std::string &document, \fBValue\fP &root, boolcollectComments = \fCtrue\fP)"

.PP
Read a \fBValue\fP from a \fCJSON\fP document\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdocument\fP UTF-8 encoded string containing the document to read\&. 
.br
\fIroot\fP [out] Contains the root value of the document if it was successfully parsed\&. 
.br
\fIcollectComments\fP \fCtrue\fP to collect comment and allow writing them back during serialization, \fCfalse\fP to discard comments\&. This parameter is ignored if \fBFeatures::allowComments_\fP is \fCfalse\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the document was successfully parsed, \fCfalse\fP if an error occurred\&. 
.RE
.PP

.PP
References document_\&.
.PP
Referenced by Json::operator>>(), and parse()\&.
.SS "bool Json::Reader::parse (const char *beginDoc, const char *endDoc, \fBValue\fP &root, boolcollectComments = \fCtrue\fP)"

.PP
Read a \fBValue\fP from a \fCJSON\fP document\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbeginDoc\fP Pointer on the beginning of the UTF-8 encoded string of the document to read\&. 
.br
\fIendDoc\fP Pointer on the end of the UTF-8 encoded string of the document to read\&. \\ Must be >= beginDoc\&. 
.br
\fIroot\fP [out] Contains the root value of the document if it was successfully parsed\&. 
.br
\fIcollectComments\fP \fCtrue\fP to collect comment and allow writing them back during serialization, \fCfalse\fP to discard comments\&. This parameter is ignored if \fBFeatures::allowComments_\fP is \fCfalse\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the document was successfully parsed, \fCfalse\fP if an error occurred\&. 
.RE
.PP

.PP
References addError(), Json::Features::allowComments_, begin_, collectComments_, Json::commentAfter, commentsBefore_, current_, Json::Reader::Token::end_, end_, errors_, features_, Json::Value::isArray(), Json::Value::isObject(), lastValue_, lastValueEnd_, nodes_, readValue(), Json::Value::setComment(), skipCommentTokens(), Json::Reader::Token::start_, Json::Features::strictRoot_, tokenError, and Json::Reader::Token::type_\&.
.SS "bool Json::Reader::parse (std::istream &is, \fBValue\fP &root, boolcollectComments = \fCtrue\fP)"

.PP
Parse from input stream\&. 
.PP
\fBSee Also:\fP
.RS 4
\fBJson::operator>>(std::istream&, Json::Value&)\fP\&. 
.RE
.PP

.PP
References parse()\&.
.SS "bool Json::Reader::readArray (\fBToken\fP &token)\fC [private]\fP"

.PP
References addErrorAndRecover(), Json::arrayValue, begin_, current_, currentValue(), nodes_, readToken(), readValue(), recoverFromError(), Json::Value::setOffsetStart(), skipSpaces(), Json::Reader::Token::start_, tokenArrayEnd, tokenArraySeparator, tokenComment, and Json::Reader::Token::type_\&.
.PP
Referenced by readValue()\&.
.SS "bool Json::Reader::readComment ()\fC [private]\fP"

.PP
References addComment(), collectComments_, Json::commentAfterOnSameLine, Json::commentBefore, Json::containsNewLine(), current_, getNextChar(), lastValueEnd_, readCppStyleComment(), and readCStyleComment()\&.
.PP
Referenced by readToken()\&.
.SS "bool Json::Reader::readCppStyleComment ()\fC [private]\fP"

.PP
References current_, end_, and getNextChar()\&.
.PP
Referenced by readComment()\&.
.SS "bool Json::Reader::readCStyleComment ()\fC [private]\fP"

.PP
References current_, end_, and getNextChar()\&.
.PP
Referenced by readComment()\&.
.SS "void Json::Reader::readNumber ()\fC [private]\fP"

.PP
References current_, end_, and Json::in()\&.
.PP
Referenced by readToken()\&.
.SS "bool Json::Reader::readObject (\fBToken\fP &token)\fC [private]\fP"

.PP
References addErrorAndRecover(), Json::Features::allowNumericKeys_, Json::Value::asString(), begin_, currentValue(), decodeNumber(), decodeString(), features_, nodes_, Json::objectValue, readToken(), readValue(), recoverFromError(), Json::Value::setOffsetStart(), Json::Reader::Token::start_, tokenArraySeparator, tokenComment, tokenMemberSeparator, tokenNumber, tokenObjectEnd, tokenString, and Json::Reader::Token::type_\&.
.PP
Referenced by readValue()\&.
.SS "bool Json::Reader::readString ()\fC [private]\fP"

.PP
References current_, end_, and getNextChar()\&.
.PP
Referenced by readToken()\&.
.SS "bool Json::Reader::readToken (\fBToken\fP &token)\fC [private]\fP"

.PP
References current_, Json::Reader::Token::end_, getNextChar(), match(), readComment(), readNumber(), readString(), skipSpaces(), Json::Reader::Token::start_, tokenArrayBegin, tokenArrayEnd, tokenArraySeparator, tokenComment, tokenEndOfStream, tokenError, tokenFalse, tokenMemberSeparator, tokenNull, tokenNumber, tokenObjectBegin, tokenObjectEnd, tokenString, tokenTrue, and Json::Reader::Token::type_\&.
.PP
Referenced by expectToken(), readArray(), readObject(), recoverFromError(), and skipCommentTokens()\&.
.SS "bool Json::Reader::readValue ()\fC [private]\fP"

.PP
References addError(), Json::Features::allowDroppedNullPlaceholders_, begin_, collectComments_, Json::commentBefore, commentsBefore_, current_, currentValue(), decodeNumber(), decodeString(), Json::Reader::Token::end_, features_, lastValue_, lastValueEnd_, readArray(), readObject(), Json::Value::setComment(), Json::Value::setOffsetLimit(), Json::Value::setOffsetStart(), skipCommentTokens(), Json::Reader::Token::start_, tokenArrayBegin, tokenArraySeparator, tokenFalse, tokenNull, tokenNumber, tokenObjectBegin, tokenString, tokenTrue, and Json::Reader::Token::type_\&.
.PP
Referenced by parse(), readArray(), and readObject()\&.
.SS "bool Json::Reader::recoverFromError (\fBTokenType\fPskipUntilToken)\fC [private]\fP"

.PP
References errors_, readToken(), and tokenEndOfStream\&.
.PP
Referenced by addErrorAndRecover(), readArray(), and readObject()\&.
.SS "void Json::Reader::skipCommentTokens (\fBToken\fP &token)\fC [private]\fP"

.PP
References Json::Features::allowComments_, features_, readToken(), tokenComment, and Json::Reader::Token::type_\&.
.PP
Referenced by parse(), and readValue()\&.
.SS "void Json::Reader::skipSpaces ()\fC [private]\fP"

.PP
References current_, and end_\&.
.PP
Referenced by readArray(), and readToken()\&.
.SS "void Json::Reader::skipUntilSpace ()\fC [private]\fP"

.SH "Member Data Documentation"
.PP 
.SS "\fBLocation\fP Json::Reader::begin_\fC [private]\fP"

.PP
Referenced by decodeDouble(), decodeNumber(), decodeString(), getLocationLineAndColumn(), getStructuredErrors(), parse(), readArray(), readObject(), and readValue()\&.
.SS "bool Json::Reader::collectComments_\fC [private]\fP"

.PP
Referenced by addComment(), parse(), readComment(), and readValue()\&.
.SS "std::string Json::Reader::commentsBefore_\fC [private]\fP"

.PP
Referenced by addComment(), parse(), and readValue()\&.
.SS "\fBLocation\fP Json::Reader::current_\fC [private]\fP"

.PP
Referenced by getNextChar(), match(), parse(), readArray(), readComment(), readCppStyleComment(), readCStyleComment(), readNumber(), readString(), readToken(), readValue(), and skipSpaces()\&.
.SS "std::string Json::Reader::document_\fC [private]\fP"

.PP
Referenced by parse()\&.
.SS "\fBLocation\fP Json::Reader::end_\fC [private]\fP"

.PP
Referenced by getLocationLineAndColumn(), getNextChar(), match(), parse(), readCppStyleComment(), readCStyleComment(), readNumber(), readString(), and skipSpaces()\&.
.SS "\fBErrors\fP Json::Reader::errors_\fC [private]\fP"

.PP
Referenced by addError(), getFormattedErrorMessages(), getStructuredErrors(), parse(), and recoverFromError()\&.
.SS "\fBFeatures\fP Json::Reader::features_\fC [private]\fP"

.PP
Referenced by parse(), readObject(), readValue(), and skipCommentTokens()\&.
.SS "\fBValue\fP* Json::Reader::lastValue_\fC [private]\fP"

.PP
Referenced by addComment(), parse(), and readValue()\&.
.SS "\fBLocation\fP Json::Reader::lastValueEnd_\fC [private]\fP"

.PP
Referenced by parse(), readComment(), and readValue()\&.
.SS "\fBNodes\fP Json::Reader::nodes_\fC [private]\fP"

.PP
Referenced by currentValue(), parse(), readArray(), and readObject()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Claims from the source code\&.
