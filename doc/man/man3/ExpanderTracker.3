.TH "ExpanderTracker" 3 "Thu Nov 12 2015" "Claims" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ExpanderTracker \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <expander_tracker\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBExpandedThreadStatus\fP"
.br
.ti -1c
.RI "struct \fBExpanderStatus\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~ExpanderTracker\fP ()"
.br
.ti -1c
.RI "bool \fBregisterNewExpandedThreadStatus\fP (\fBexpanded_thread_id\fP id, \fBExpanderID\fP exp_id)"
.br
.ti -1c
.RI "bool \fBdeleteExpandedThreadStatus\fP (\fBexpanded_thread_id\fP id)"
.br
.ti -1c
.RI "bool \fBisExpandedThreadCallBack\fP (\fBexpanded_thread_id\fP id)"
.br
.ti -1c
.RI "bool \fBcallbackExpandedThread\fP (\fBexpanded_thread_id\fP id)"
.br
.ti -1c
.RI "bool \fBaddNewStageEndpoint\fP (\fBexpanded_thread_id\fP, \fBLocalStageEndPoint\fP)"
.br
.ti -1c
.RI "\fBPerformanceInfo\fP * \fBgetPerformanceInfo\fP (\fBexpanded_thread_id\fP)"
.br
.ti -1c
.RI "\fBExpanderID\fP \fBregisterNewExpander\fP (\fBMonitorableBuffer\fP *buffer, \fBExpandabilityShrinkability\fP *expand_shrink)"
.br
.ti -1c
.RI "void \fBunregisterExpander\fP (\fBExpanderID\fP expander_id)"
.br
.ti -1c
.RI "bool \fBtrackExpander\fP (\fBExpanderID\fP id) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBExpanderTracker\fP * \fBgetInstance\fP ()"
.br
.ti -1c
.RI "static \fBsegment_status\fP \fBgetSegmentStatus\fP (\fBlocal_stage\fP &)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "std::map< \fBexpanded_thread_id\fP, 
.br
\fBExpandedThreadStatus\fP > \fBid_to_status_\fP"
.br
.ti -1c
.RI "\fBLogging\fP * \fBlog_\fP"
.br
.ti -1c
.RI "pthread_t \fBmonitor_thread_id_\fP"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBsegment_status\fP { \fBseg_no_producing\fP, \fBseg_normal_producing\fP, \fBseg_over_producing\fP, \fBseg_under_producing\fP }"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBExpanderTracker\fP ()"
.br
.ti -1c
.RI "int \fBdecideExpandingOrShrinking\fP (\fBlocal_stage\fP &current_stage, unsigned int current_degree_of_parallelism, bool print=true)"
.br
.ti -1c
.RI "int \fBexpandeIfNotExceedTheMaxDegreeOfParallelism\fP (int current_degree_of_parallelism) const "
.br
.ti -1c
.RI "int \fBshrinkIfNotExceedTheMinDegreeOfParallelims\fP (int current_degree_of_parallelism) const "
.br
.ti -1c
.RI "void \fBprintStatus\fP ()"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static void * \fBmonitoringThread\fP (void *arg)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBLock\fP \fBlock_\fP"
.br
.ti -1c
.RI "boost::unordered_map
.br
< \fBexpanded_thread_id\fP, 
.br
\fBExpanderID\fP > \fBthread_id_to_expander_id_\fP"
.br
.ti -1c
.RI "boost::unordered_map
.br
< \fBExpanderID\fP, \fBExpanderStatus\fP * > \fBexpander_id_to_status_\fP"
.br
.ti -1c
.RI "boost::unordered_map
.br
< \fBExpanderID\fP, 
.br
\fBExpandabilityShrinkability\fP * > \fBexpander_id_to_expand_shrink_\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBExpanderTracker\fP * \fBinstance_\fP = 0"
.br
.in -1c
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBExpanderTracker::segment_status\fP\fC [private]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIseg_no_producing \fP\fP
.TP
\fB\fIseg_normal_producing \fP\fP
.TP
\fB\fIseg_over_producing \fP\fP
.TP
\fB\fIseg_under_producing \fP\fP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ExpanderTracker::~ExpanderTracker ()\fC [virtual]\fP"

.PP
References instance_, log_, and monitor_thread_id_\&.
.SS "ExpanderTracker::ExpanderTracker ()\fC [private]\fP"

.PP
References Logging::log(), log_, monitor_thread_id_, and monitoringThread()\&.
.PP
Referenced by getInstance()\&.
.SH "Member Function Documentation"
.PP 
.SS "bool ExpanderTracker::addNewStageEndpoint (\fBexpanded_thread_id\fPtid, \fBLocalStageEndPoint\fPendpoint)"

.PP
References Lock::acquire(), expander_id_to_status_, lock_, Lock::release(), and thread_id_to_expander_id_\&.
.PP
Referenced by claims::physical_operator::PhysicalNestLoopJoin::Open(), claims::physical_operator::PhysicalAggregation::Open(), claims::physical_operator::ExchangeMerger::Open(), claims::physical_operator::PhysicalProjectionScan::Open(), and claims::physical_operator::PhysicalHashJoin::Open()\&.
.SS "bool ExpanderTracker::callbackExpandedThread (\fBexpanded_thread_id\fPid)"

.PP
References Lock::acquire(), id_to_status_, lock_, and Lock::release()\&.
.PP
Referenced by claims::physical_operator::Expander::TerminateWorkingThread()\&.
.SS "int ExpanderTracker::decideExpandingOrShrinking (\fBlocal_stage\fP &current_stage, unsigned intcurrent_degree_of_parallelism, boolprint = \fCtrue\fP)\fC [private]\fP"
In the initial implementation, if all expanded threads are shrunk and the condition for expanding will never be triggered due to the exhaust of input data-flow, then the remaining work will never be done\&.
.PP
To avoid this problem, we should first check whether the dataflow is exhausted\&. If so, we should guarantee that there is at least one expanded threads to process the remaining data in buffer\&.
.PP
Currently, for the stage without synchronization all_merged_data_buffer_, the workload is not known and hence maximum degree of parallelism is used\&.
.PP
References local_stage::buffer_to_buffer, local_stage::dataflow_desc_, local_stage::dataflow_src_, DECISION_EXPAND, DECISION_KEEP, DECISION_SHRINK, expandeIfNotExceedTheMaxDegreeOfParallelism(), local_stage::from_buffer, MonitorableBuffer::getBufferUsage(), local_stage::incomplete, MonitorableBuffer::inputComplete(), Logging::log(), log_, Config::max_degree_of_parallelism, LocalStageEndPoint::monitorable_buffer, local_stage::no_buffer, shrinkIfNotExceedTheMinDegreeOfParallelims(), SWITCHER, THRESHOLD_EMPTY, THRESHOLD_FULL, local_stage::to_buffer, and local_stage::type_\&.
.PP
Referenced by monitoringThread()\&.
.SS "bool ExpanderTracker::deleteExpandedThreadStatus (\fBexpanded_thread_id\fPid)"

.PP
References Lock::acquire(), id_to_status_, lock_, Lock::release(), and thread_id_to_expander_id_\&.
.PP
Referenced by claims::physical_operator::Expander::ExpandedWork()\&.
.SS "int ExpanderTracker::expandeIfNotExceedTheMaxDegreeOfParallelism (intcurrent_degree_of_parallelism) const\fC [private]\fP"

.PP
References DECISION_EXPAND, DECISION_KEEP, and Config::max_degree_of_parallelism\&.
.PP
Referenced by decideExpandingOrShrinking()\&.
.SS "\fBExpanderTracker\fP * ExpanderTracker::getInstance ()\fC [static]\fP"

.PP
References ExpanderTracker(), and instance_\&.
.PP
Referenced by claims::physical_operator::PhysicalOperator::CheckTerminateRequest(), claims::physical_operator::Expander::Close(), claims::physical_operator::ExchangeMerger::CreatePerformanceInfo(), Environment::Environment(), claims::physical_operator::Expander::ExpandedWork(), claims::physical_operator::PhysicalAggregation::Next(), claims::physical_operator::PhysicalProjectionScan::Next(), claims::physical_operator::Expander::Open(), claims::physical_operator::PhysicalNestLoopJoin::Open(), claims::physical_operator::PhysicalAggregation::Open(), claims::physical_operator::ExchangeMerger::Open(), claims::physical_operator::PhysicalProjectionScan::Open(), claims::physical_operator::PhysicalHashJoin::Open(), and claims::physical_operator::Expander::TerminateWorkingThread()\&.
.SS "\fBPerformanceInfo\fP * ExpanderTracker::getPerformanceInfo (\fBexpanded_thread_id\fPtid)"

.PP
References Lock::acquire(), expander_id_to_status_, lock_, Lock::release(), and thread_id_to_expander_id_\&.
.PP
Referenced by claims::physical_operator::ExchangeMerger::CreatePerformanceInfo(), claims::physical_operator::PhysicalAggregation::Open(), and claims::physical_operator::PhysicalProjectionScan::Open()\&.
.SS "\fBExpanderTracker::segment_status\fP ExpanderTracker::getSegmentStatus (\fBlocal_stage\fP &current_stage)\fC [static]\fP"

.PP
References local_stage::buffer_to_buffer, local_stage::dataflow_desc_, local_stage::dataflow_src_, local_stage::from_buffer, MonitorableBuffer::getBufferUsage(), local_stage::incomplete, LocalStageEndPoint::monitorable_buffer, local_stage::no_buffer, refine, seg_no_producing, seg_normal_producing, seg_over_producing, seg_under_producing, THRESHOLD_EMPTY, THRESHOLD_FULL, local_stage::to_buffer, and local_stage::type_\&.
.SS "bool ExpanderTracker::isExpandedThreadCallBack (\fBexpanded_thread_id\fPid)"

.PP
References Lock::acquire(), id_to_status_, lock_, and Lock::release()\&.
.PP
Referenced by claims::physical_operator::PhysicalOperator::CheckTerminateRequest()\&.
.SS "void * ExpanderTracker::monitoringThread (void *arg)\fC [static]\fP, \fC [private]\fP"

.PP
References Lock::acquire(), curtick(), decideExpandingOrShrinking(), DECISION_EXPAND, DECISION_SHRINK, Config::enable_expander_adaptivity, Config::expander_adaptivity_check_frequency, expander_id_to_expand_shrink_, expander_id_to_status_, lock_, Logging::log(), log_, Lock::release(), and SWITCHER\&.
.PP
Referenced by ExpanderTracker()\&.
.SS "void ExpanderTracker::printStatus ()\fC [private]\fP"

.PP
References expander_id_to_expand_shrink_, expander_id_to_status_, id_to_status_, and thread_id_to_expander_id_\&.
.SS "bool ExpanderTracker::registerNewExpandedThreadStatus (\fBexpanded_thread_id\fPid, \fBExpanderID\fPexp_id)"

.PP
References Lock::acquire(), ExpanderTracker::ExpandedThreadStatus::call_back_, expander_id_to_expand_shrink_, id_to_status_, lock_, Lock::release(), and thread_id_to_expander_id_\&.
.PP
Referenced by claims::physical_operator::Expander::ExpandedWork()\&.
.SS "\fBExpanderID\fP ExpanderTracker::registerNewExpander (\fBMonitorableBuffer\fP *buffer, \fBExpandabilityShrinkability\fP *expand_shrink)"

.PP
References Lock::acquire(), expander_id_to_expand_shrink_, expander_id_to_status_, IDsGenerator::getInstance(), IDsGenerator::getUniqueExpanderID(), lock_, Logging::log(), log_, Lock::release(), and stage_desc\&.
.PP
Referenced by claims::physical_operator::Expander::Open()\&.
.SS "int ExpanderTracker::shrinkIfNotExceedTheMinDegreeOfParallelims (intcurrent_degree_of_parallelism) const\fC [private]\fP"

.PP
References DECISION_KEEP, and DECISION_SHRINK\&.
.PP
Referenced by decideExpandingOrShrinking()\&.
.SS "bool ExpanderTracker::trackExpander (\fBExpanderID\fPid) const"

.PP
References expander_id_to_expand_shrink_, and expander_id_to_status_\&.
.SS "void ExpanderTracker::unregisterExpander (\fBExpanderID\fPexpander_id)"

.PP
References Lock::acquire(), expander_id_to_expand_shrink_, expander_id_to_status_, lock_, Lock::release(), and thread_id_to_expander_id_\&.
.PP
Referenced by claims::physical_operator::Expander::Close()\&.
.SH "Member Data Documentation"
.PP 
.SS "boost::unordered_map<\fBExpanderID\fP,\fBExpandabilityShrinkability\fP*> ExpanderTracker::expander_id_to_expand_shrink_\fC [private]\fP"

.PP
Referenced by monitoringThread(), printStatus(), registerNewExpandedThreadStatus(), registerNewExpander(), trackExpander(), and unregisterExpander()\&.
.SS "boost::unordered_map<\fBExpanderID\fP,\fBExpanderStatus\fP*> ExpanderTracker::expander_id_to_status_\fC [private]\fP"

.PP
Referenced by addNewStageEndpoint(), getPerformanceInfo(), monitoringThread(), printStatus(), registerNewExpander(), trackExpander(), and unregisterExpander()\&.
.SS "std::map<\fBexpanded_thread_id\fP,\fBExpandedThreadStatus\fP> ExpanderTracker::id_to_status_"

.PP
Referenced by callbackExpandedThread(), deleteExpandedThreadStatus(), isExpandedThreadCallBack(), printStatus(), and registerNewExpandedThreadStatus()\&.
.SS "\fBExpanderTracker\fP * ExpanderTracker::instance_ = 0\fC [static]\fP, \fC [private]\fP"
Ideally, this should be guaranteed by resource manager\&. 
.PP
Referenced by getInstance(), and ~ExpanderTracker()\&.
.SS "\fBLock\fP ExpanderTracker::lock_\fC [private]\fP"

.PP
Referenced by addNewStageEndpoint(), callbackExpandedThread(), deleteExpandedThreadStatus(), getPerformanceInfo(), isExpandedThreadCallBack(), monitoringThread(), registerNewExpandedThreadStatus(), registerNewExpander(), and unregisterExpander()\&.
.SS "\fBLogging\fP* ExpanderTracker::log_"

.PP
Referenced by decideExpandingOrShrinking(), ExpanderTracker(), monitoringThread(), registerNewExpander(), and ~ExpanderTracker()\&.
.SS "pthread_t ExpanderTracker::monitor_thread_id_"

.PP
Referenced by ExpanderTracker(), and ~ExpanderTracker()\&.
.SS "boost::unordered_map<\fBexpanded_thread_id\fP,\fBExpanderID\fP> ExpanderTracker::thread_id_to_expander_id_\fC [private]\fP"

.PP
Referenced by addNewStageEndpoint(), deleteExpandedThreadStatus(), getPerformanceInfo(), printStatus(), registerNewExpandedThreadStatus(), and unregisterExpander()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Claims from the source code\&.
